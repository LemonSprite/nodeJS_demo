1、作用域链及闭包
      当某个函数调用的时候，便会创建对应的执行环境和作用域链，并将作用域链赋值给属性[[Scope]]。[[Scope]]属性仅JS引擎才能访问。
    作用域链保存着指向各变量对象的指针。链的的顶端变量对象为当前函数的活动对象。
      闭包：在调用一个函数时，其内又调用另外一个函数情况。外部函数执行的时候生成活动对象，其对象地址保存在在外部函数作用域链的
    顶端，也保存在内部函数作用域链的第二位置。均是指向同一对象。所以内部函数完全有权限访问外部函数变量。问题就在于，一般来说，
    当一个函数结束之后，其活动对象同时销毁。而由于JS函数可以做参数的特性，其外部函数是可以比内部函数先结束，比如常见的nodejs
    异步函数操作。
      所以为了解决这个忧伤的问题，就让外部函数结束的时候，其活动对象并不销毁，依然让内部函数作用域链对其有引用，只有当内部函数
    结束的时候才销毁。  

2、对象字面量：是一种objec类型，另一种是new Objec()形式。
   var person = {name : "liu", age : 10};//左边可以是标识符形式, 引用方式：person.name  和 person["name"],不能是person[name]
   var person = {"*" : "liu", "liu" : 10};//左边为string形式，可以为任何字符.方式： person["*"],如果是合格表示符，可以person.liu。
   var person = {};//类似于new Object()
   对象字面量里面属性的赋值不能用 = 等号，必须使用 ：冒号。
   但是在外面可以用=等号：var person = {}; person["/liu"] = function(){};//这样完全可行

3、严格模式 
      严格模式下为了防止给全局变量赋值，要求局部变量必须使用var申明，这里不针对实例变量和类变量。函数中的this不能执行全局对象
   ，因为在非严格模式下，在全局环境下调用函数里面如果存在this.temp形式变量赋值，实质上还是创建了一个temp全局变量，这是不允许的。所以在严格模式下，直接指定这种情况this为undefined。

4、JS没有块级作用域。
      最小的作用域为函数。也就是说在for、if-else等语句内使用var定义的变量，在函数内均可访问到。
      不过上有政策，下有对策。还是可以利用函数来达到块级作用域的目的。使用函数表达式形式(function(){...})()即可。
      function(){}形式为函数声明，后面不能加圆括号()表示执行。
      (function(){})()形式为函数表达式，后面可以加圆括号()，表示函数执行。                                                                                                                                                                            
5、node是单线程，不是多线程并发执行任务。那么怎么保持大量客户访问下的执行速度，造成阻塞呢？
      node的并发量就是1，单线程执行javascript代码，快的原因就是在V8引擎执行javascript代码非常快，调用堆栈执行
   非常快，同时配合非阻塞IO任务操作，这样就造成非常快了,这里非阻塞IO确保单线程执行时，不会因为数据库访问或者
   硬盘访问等操作而导致挂起等待。其实像其他的web服务端并发需要开新线程，新开线程也是需要费时间的。      

6、关于路径等操作，可以利用__dirname、__filename和模块path里面dirname()、extname() 
   等方法组合使用，也可以使用其他第三方工具模块像lodash等。使用path模块需注意，文件系统不检查具体路径的是否有效，
   只是针对string进行路径格式处理。

7、events模块
      EventEmitter 其监听方法on(event, cb)只能监听本身emit(event,arg,..)方法发出的事件消息。其对象除了函数
   EventEmitter.listCount()和属性EventEmitter.defaultMaxListeners(默认10)外，其他均属于prototype方法，需要
   通过new出实例对象调用。

8、代码中有需要使用继承，最好利用util模块inherits(constructor, superConstructor)方法。

9、async.series(
  [
   function(cb){cb(err, result,..);},
   function(cb){cb(err, result,..);}
  ], 
  function(err, results){}
   );

     //这个results是接受上面所有result值得数组
     两个参数，一个函数执行数组，一个结果处理函数。每个函数的执行时串行，即使内部使用异步函数。每个函数没有参数交互，独立。

   其中个cb回调函数是这个series提供的必须写，因为这是控制顺序流程的核心，只要series函数检测到task函数数组中，某一个

   函数内调用cb(xx,xx)。那么series便认为这个函数执行完成，便开始执行下一个函数。

     最有一个参数：处理函数。如果前面每个函数的cb(err,result)中的err都没有抛出错误，那么最后results便是以每个cb(err, result)

   中的result组成的数组。但是只要其中一个cb(err,result)抛出错误，那么直接终止进入处理函数，函数中results的值为当前函数及

   之前函数cb中的每个result。

     每个cb(err, result1, result2, ...) 一个参数必须是err处理, 后面的参数做结果处理,如果在某一task 函数中cb result参数有

   很多个，那么最终在处理函数中results数组中这一项内部又以一个子数组显示其结果。[[result1.1, result1.2], result2, ...]


    async.waterfall(
    [
    function(cb){ cb(err, 'liu', 'zhong'); },
    function(arg1, arg2, cb){ console.log(arg1, arg2); cb(err, 'shi')},
    function(arg1, cb){ ...; cb(err, 'god'); }
    ],
    function(err, result){}//这个result只接受最后一个task函数的第二个,此处为'god'
    );
   
      //处理函数中result不接受数组，只接受一个参数。如果最后一个task函数没有第二个参数则为undifined，有3、4、5很多个参数
      //只取第二个参数。

      利用cb，前面的task函数将结果，传到下一个函数作为参数。任何一个抛错，则停止执行到处理函数。

10、关于module.exports 和 exports：
      事实上模块导出始终固定是module.exports,意思是先找到module，然后系统导出其属性exports（初始为空对象{}），
   每个模块都会自动创建一个module对象，其有一个属性exports为空对象{}。然后还有一个Object类型引用exports指向
   module.exports。
      所以很明显，我们不能直接给exports=xx赋值，然后导出部分只写了exports = xx函数; 因为module.exports，还是为
   空，exports指针指向别的对象。所以其实上面的我们写成exports.start = start;是可以得，因为exports还是指向module.exports

11、字符集：规定了哪些字符、文字等纳入集合中，规定了每个符号的二进制代码。
   编码：规定了每个字符如何存储。
   例如unicode字符集，而UTF-8是unicode字符集的一种编码。

12、中间件
      middleware是一个函数，它可以访问请求对象req，响应对象res，和web应用中处于请求-响应循环流程中的中间件，一般命名next变量
   功能：执行任何代码、修改请求和响应对象、终结请求-响应循环、调用堆栈中的下一个中间件
   NOTE：如果当前中间件没有终结请求-响应循环，则必须调用next()方法将控制权交给下一个中间件，否则请求挂起。
   分类：应用级   ：绑定到 app 对象，使用app.use()
         路由级   ：使用到 express.Router() 对象，router.use(),get(),post()等
         错误处理 ：必须含有四个参数(err, req, res, next)。app.use()
         内置     : express.static 是express唯一内置的中间件了。基于 serve-static，负责在express托管静态资源。
                    express.static(root,[options])。root为根目录，options为相关设置，见：http://www.expressjs.com.cn/guide/using-middleware.html                   
         第三方   ：可在应用级加载也可在路由级加载。

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        